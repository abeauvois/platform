# Release workflow with semantic versioning
# Creates releases based on conventional commits

name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Perform a dry run without publishing"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

env:
  BUN_VERSION: "1.3.5"

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Cache dependencies
        uses: actions/cache@v5
        with:
          path: |
            ~/.bun/install/cache
            node_modules
            **/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('**/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build all packages
        run: bun run build

      - name: Calculate next version
        id: version
        uses: actions/github-script@v8
        with:
          script: |
            const { execSync } = require('child_process');

            // Get the latest tag (by version, not by commit ancestry)
            let latestTag;
            try {
              // Use git tag with version sort to find latest, regardless of commit ancestry
              latestTag = execSync('git tag --sort=-v:refname | head -1', { encoding: 'utf8' }).trim();
              if (!latestTag) latestTag = null;
            } catch {
              latestTag = null;
            }

            // Get commit messages since last tag
            const range = latestTag ? `${latestTag}..HEAD` : 'HEAD';
            const commits = execSync(`git log ${range} --pretty=format:"%h %s" --no-merges`, { encoding: 'utf8' })
              .split('\n')
              .filter(Boolean);

            if (commits.length === 0) {
              console.log('No new commits since last release');
              core.setOutput('skip', 'true');
              return;
            }

            // Parse conventional commits
            const features = [];
            const fixes = [];
            const breaking = [];
            const other = [];

            for (const commit of commits) {
              const [hash, ...messageParts] = commit.split(' ');
              const message = messageParts.join(' ');

              if (message.startsWith('feat:') || message.startsWith('feat(')) {
                features.push({ hash, message });
              } else if (message.startsWith('fix:') || message.startsWith('fix(')) {
                fixes.push({ hash, message });
              } else if (message.includes('BREAKING CHANGE') || message.includes('!:')) {
                breaking.push({ hash, message });
              } else if (!message.startsWith('chore:') && !message.startsWith('docs:')) {
                other.push({ hash, message });
              }
            }

            // Determine version bump
            let bump = 'patch';
            if (breaking.length > 0) bump = 'major';
            else if (features.length > 0) bump = 'minor';

            // Calculate new version
            const currentVersion = latestTag ? latestTag.replace('v', '') : '0.0.0';
            const [major, minor, patch] = currentVersion.split('.').map(Number);

            let newVersion;
            switch (bump) {
              case 'major':
                newVersion = `${major + 1}.0.0`;
                break;
              case 'minor':
                newVersion = `${major}.${minor + 1}.0`;
                break;
              default:
                newVersion = `${major}.${minor}.${patch + 1}`;
            }

            // Generate release notes
            let releaseNotes = `## What's Changed\n\n`;

            if (breaking.length > 0) {
              releaseNotes += `### Breaking Changes\n`;
              for (const { hash, message } of breaking) {
                releaseNotes += `- ${message} (${hash})\n`;
              }
              releaseNotes += '\n';
            }

            if (features.length > 0) {
              releaseNotes += `### Features\n`;
              for (const { hash, message } of features) {
                releaseNotes += `- ${message} (${hash})\n`;
              }
              releaseNotes += '\n';
            }

            if (fixes.length > 0) {
              releaseNotes += `### Bug Fixes\n`;
              for (const { hash, message } of fixes) {
                releaseNotes += `- ${message} (${hash})\n`;
              }
              releaseNotes += '\n';
            }

            if (other.length > 0) {
              releaseNotes += `### Other Changes\n`;
              for (const { hash, message } of other) {
                releaseNotes += `- ${message} (${hash})\n`;
              }
              releaseNotes += '\n';
            }

            releaseNotes += `**Full Changelog**: https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${latestTag || 'initial'}...v${newVersion}`;

            // Check for dry run
            if ('${{ inputs.dry_run }}' === 'true') {
              console.log('Dry run - would create release:');
              console.log(`Version: v${newVersion}`);
              console.log('Release notes:');
              console.log(releaseNotes);
              core.setOutput('skip', 'true');
              return;
            }

            // Check if release already exists
            try {
              const existingRelease = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: `v${newVersion}`
              });
              console.log(`Release v${newVersion} already exists: ${existingRelease.data.html_url}`);
              core.setOutput('skip', 'true');
              return;
            } catch (error) {
              if (error.status !== 404) throw error;
            }

            core.setOutput('skip', 'false');
            core.setOutput('version', newVersion);
            // Write release notes to file to avoid escaping issues
            const fs = require('fs');
            fs.writeFileSync('release_notes.md', releaseNotes);
            console.log(`Will create release v${newVersion}`);

      - name: Sync package versions
        if: steps.version.outputs.skip != 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Syncing all packages to version $VERSION"

          # Update root package.json
          jq --arg v "$VERSION" '.version = $v' package.json > tmp.json && mv tmp.json package.json

          # Update all package versions
          for pkg in packages/*/package.json; do
            echo "  Updating $pkg"
            jq --arg v "$VERSION" '.version = $v' "$pkg" > tmp.json && mv tmp.json "$pkg"
          done

          # Update all app versions
          for app in apps/*/package.json; do
            if [ -f "$app" ]; then
              echo "  Updating $app"
              jq --arg v "$VERSION" '.version = $v' "$app" > tmp.json && mv tmp.json "$app"
            fi
          done

      - name: Commit version sync
        if: steps.version.outputs.skip != 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add package.json packages/*/package.json apps/*/package.json
          git commit -m "chore: bump version to $VERSION [skip ci]"
          git push

      - name: Create GitHub Release
        id: release
        if: steps.version.outputs.skip != 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');

            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.version.outputs.version }}`,
              name: `v${{ steps.version.outputs.version }}`,
              body: releaseNotes,
              draft: false,
              prerelease: false,
              generate_release_notes: false
            });

            console.log(`Created release: ${release.data.html_url}`);
            core.setOutput('release_url', release.data.html_url);

      - name: Trigger publish workflow
        if: steps.version.outputs.skip != 'true'
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'publish-packages.yml',
              ref: 'main'
            });
            console.log('Triggered publish-packages workflow');

      - name: Notify release
        if: steps.version.outputs.skip != 'true'
        run: |
          echo "::notice::Released version ${{ steps.version.outputs.version }}"
          echo "Release URL: ${{ steps.release.outputs.release_url }}"
