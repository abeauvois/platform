# Deployment workflow for Railway
# Deploys apps on release or manual trigger

name: Deploy

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      app:
        description: "App to deploy"
        required: true
        default: "api"
        type: choice
        options:
          - api
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

permissions:
  contents: read
  deployments: write
  checks: write

env:
  BUN_VERSION: "1.3.5"
  RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

jobs:
  # Determine deployment parameters
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      app: ${{ steps.params.outputs.app }}
      environment: ${{ steps.params.outputs.environment }}
      service_id: ${{ steps.params.outputs.service_id }}
    steps:
      - name: Set deployment parameters
        id: params
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_APP: ${{ inputs.app }}
          INPUT_ENV: ${{ inputs.environment }}
          API_PROD_SERVICE_ID: ${{ secrets.RAILWAY_API_PROD_SERVICE_ID }}
          API_STAGING_SERVICE_ID: ${{ secrets.RAILWAY_API_STAGING_SERVICE_ID }}
        run: |
          if [[ "$EVENT_NAME" == "release" ]]; then
            echo "app=api" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "service_id=$API_PROD_SERVICE_ID" >> $GITHUB_OUTPUT
          else
            echo "app=$INPUT_APP" >> $GITHUB_OUTPUT
            echo "environment=$INPUT_ENV" >> $GITHUB_OUTPUT

            # Map app + environment to Railway service IDs
            if [[ "$INPUT_APP" == "api" && "$INPUT_ENV" == "staging" ]]; then
              echo "service_id=$API_STAGING_SERVICE_ID" >> $GITHUB_OUTPUT
            elif [[ "$INPUT_APP" == "api" && "$INPUT_ENV" == "production" ]]; then
              echo "service_id=$API_PROD_SERVICE_ID" >> $GITHUB_OUTPUT
            fi
          fi

  # Run database migrations before deploying
  migrate:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - uses: actions/checkout@v6

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run migrations
        env:
          DATABASE_URL: ${{ needs.setup.outputs.environment == 'production' && secrets.DATABASE_URL_PRODUCTION || secrets.DATABASE_URL_STAGING }}
        run: |
          echo "Running migrations for ${{ needs.setup.outputs.environment }}..."
          cd packages/platform-db
          bunx drizzle-kit migrate
          echo "Migrations completed successfully"

  # Deploy to Railway
  deploy:
    name: Deploy to Railway
    runs-on: ubuntu-latest
    needs: [setup, migrate]
    environment:
      name: ${{ needs.setup.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}
    outputs:
      deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
      check_run_id: ${{ steps.create-check.outputs.check_run_id }}
    steps:
      - uses: actions/checkout@v6

      - name: Create GitHub Deployment
        id: create-deployment
        uses: actions/github-script@v8
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ needs.setup.outputs.environment }}',
              auto_merge: false,
              required_contexts: [],
              description: 'Deploying ${{ needs.setup.outputs.app }} to ${{ needs.setup.outputs.environment }}'
            });

            if (deployment.status === 201) {
              core.setOutput('deployment_id', deployment.data.id);
              console.log(`Created deployment ${deployment.data.id}`);
            } else {
              core.setFailed(`Failed to create deployment: ${deployment.status}`);
            }

      - name: Update Deployment Status to In Progress
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.create-deployment.outputs.deployment_id }},
              state: 'in_progress',
              description: 'Deployment in progress...'
            });

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Install Railway CLI
        run: |
          curl -fsSL https://railway.app/install.sh | sh
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Deploy ${{ needs.setup.outputs.app }} to ${{ needs.setup.outputs.environment }}
        id: deploy
        working-directory: apps/${{ needs.setup.outputs.app }}
        run: |
          # Deploy using Railway CLI
          railway up --service ${{ needs.setup.outputs.service_id }} --detach

          # Wait for deployment to complete
          echo "Waiting for deployment to complete..."
          sleep 30

          # Get deployment URL from Railway
          DOMAIN=$(railway domain --service ${{ needs.setup.outputs.service_id }} 2>/dev/null || echo "")
          if [[ -n "$DOMAIN" ]]; then
            echo "url=https://$DOMAIN" >> $GITHUB_OUTPUT
          else
            # Fallback to default Railway domain pattern
            echo "url=https://${{ needs.setup.outputs.app }}-${{ needs.setup.outputs.environment }}.up.railway.app" >> $GITHUB_OUTPUT
          fi

      - name: Create Health Check Run
        id: create-check
        uses: actions/github-script@v8
        with:
          script: |
            const check = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Railway Health Check (${{ needs.setup.outputs.environment }})',
              head_sha: context.sha,
              status: 'in_progress',
              started_at: new Date().toISOString(),
              output: {
                title: 'Health Check',
                summary: 'Running health checks against deployed service...'
              }
            });
            core.setOutput('check_run_id', check.data.id);
            console.log(`Created check run ${check.data.id}`);

      - name: Run Health Checks
        id: health-check
        uses: actions/github-script@v8
        with:
          script: |
            const deployUrl = '${{ steps.deploy.outputs.url }}';
            const checkRunId = ${{ steps.create-check.outputs.check_run_id }};
            const deploymentId = ${{ steps.create-deployment.outputs.deployment_id }};
            const maxAttempts = 10;
            const delayMs = 10000;

            const results = [];
            let success = false;
            let lastError = null;

            console.log(`Running health checks against ${deployUrl}/api/health`);

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const startTime = Date.now();
              let status = 'unknown';
              let responseTime = 0;
              let error = null;

              try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);

                const response = await fetch(`${deployUrl}/api/health`, {
                  signal: controller.signal
                });
                clearTimeout(timeout);

                responseTime = Date.now() - startTime;
                status = response.status.toString();

                if (response.ok) {
                  const body = await response.json();
                  results.push({ attempt, status, responseTime, body: JSON.stringify(body) });
                  success = true;
                  console.log(`Attempt ${attempt}: Success (${responseTime}ms)`);
                  break;
                } else {
                  results.push({ attempt, status, responseTime, error: `HTTP ${status}` });
                  console.log(`Attempt ${attempt}: HTTP ${status} (${responseTime}ms)`);
                }
              } catch (err) {
                responseTime = Date.now() - startTime;
                error = err.name === 'AbortError' ? 'Timeout' : err.message;
                lastError = error;
                results.push({ attempt, status: 'error', responseTime, error });
                console.log(`Attempt ${attempt}: ${error} (${responseTime}ms)`);
              }

              // Update check run with progress
              await github.rest.checks.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: checkRunId,
                output: {
                  title: 'Health Check',
                  summary: `Attempt ${attempt}/${maxAttempts}...`,
                  text: results.map(r => `- Attempt ${r.attempt}: ${r.status} (${r.responseTime}ms)${r.error ? ` - ${r.error}` : ''}`).join('\n')
                }
              });

              if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, delayMs));
              }
            }

            // Build results table
            const table = [
              '| Attempt | Status | Response Time | Details |',
              '|---------|--------|---------------|---------|',
              ...results.map(r => `| ${r.attempt} | ${r.status} | ${r.responseTime}ms | ${r.error || r.body || '-'} |`)
            ].join('\n');

            const summary = success
              ? `Health check passed on attempt ${results.length}`
              : `Health check failed after ${maxAttempts} attempts. Last error: ${lastError}`;

            // Update check run with final status
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              status: 'completed',
              conclusion: success ? 'success' : 'failure',
              completed_at: new Date().toISOString(),
              output: {
                title: success ? 'Health Check Passed' : 'Health Check Failed',
                summary: summary,
                text: `## Health Check Results\n\n${table}\n\n**URL:** ${deployUrl}/api/health`
              }
            });

            // Update deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: success ? 'success' : 'failure',
              environment_url: deployUrl,
              description: success ? 'Deployment successful' : 'Health check failed'
            });

            if (!success) {
              core.setFailed(`Health check failed after ${maxAttempts} attempts`);
            }

      - name: Notify deployment success
        if: success()
        run: |
          echo "::notice::Successfully deployed ${{ needs.setup.outputs.app }} to ${{ needs.setup.outputs.environment }}"
          echo "URL: ${{ steps.deploy.outputs.url }}"

      - name: Handle deployment failure
        if: failure()
        uses: actions/github-script@v8
        with:
          script: |
            const deploymentId = '${{ steps.create-deployment.outputs.deployment_id }}';
            const checkRunId = '${{ steps.create-check.outputs.check_run_id }}';

            // Update deployment status to failure if deployment was created
            if (deploymentId && deploymentId !== '') {
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: parseInt(deploymentId),
                state: 'failure',
                description: 'Deployment failed'
              });
            }

            // Update check run to failure if check was created
            if (checkRunId && checkRunId !== '') {
              await github.rest.checks.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: parseInt(checkRunId),
                status: 'completed',
                conclusion: 'failure',
                completed_at: new Date().toISOString(),
                output: {
                  title: 'Deployment Failed',
                  summary: 'The deployment failed before health checks could complete.'
                }
              });
            }

            core.error('Failed to deploy ${{ needs.setup.outputs.app }} to ${{ needs.setup.outputs.environment }}')

  # Rollback on failure (production only)
  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: failure() && needs.setup.outputs.environment == 'production'
    steps:
      - name: Install Railway CLI
        run: |
          curl -fsSL https://railway.app/install.sh | sh
          echo "$HOME/.railway/bin" >> $GITHUB_PATH

      - name: Rollback deployment
        run: |
          echo "Rolling back ${{ needs.setup.outputs.app }}"
          # Railway automatically keeps previous deployments
          # Use railway rollback or redeploy previous version
          railway rollback --service ${{ needs.setup.outputs.service_id }} || {
            echo "::warning::Auto-rollback not available. Please rollback manually from Railway dashboard."
          }
